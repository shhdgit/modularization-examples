{"b3bda600-f03b-5162-bc90-a876ab1c2312":{"id":"b3bda600-f03b-5162-bc90-a876ab1c2312","path":"/README","title":"症状","excerpt":"https://autonomy.design 症状 如果没有做好业务逻辑拆分，可能在项目晚期造成以下三种问题： 拆了微服务之后做一个需求要拉很多人，代码写进来了就再也删不掉了 要么放任自流，1个App里有…"},"a08d1cc3-8095-578d-ae11-3d428cdadb2e":{"id":"a08d1cc3-8095-578d-ae11-3d428cdadb2e","path":"/all-in-one","title":"如何不 Review 每一行代码，同时保持代码不被写乱","excerpt":"如何不 Review 每一行代码，同时保持代码不被写乱 本文的读者 你为代码总是被同事们写乱了而苦恼，但是又无法 Review 每一行代码 你要开发一个 SaaS，实现各种复杂功能的组合，但是又不能像互联网公司一样堆很多人来开发微服务 你模仿过主流的微服务，DDD…"},"1047f885-6446-59b5-82b1-a77666fb56f5":{"id":"1047f885-6446-59b5-82b1-a77666fb56f5","path":"/modularization","title":"模块化的三个目的","excerpt":"Autonomy 所有人似乎都在修改同一个文件，例如 order.php。所有需求似乎都堆积在少数几个人的身上。所有团队似乎都等着同一个模块的上线，但是一天只有24小时，没有足够的时间去在生产环境验证新部署的可靠性。公司里的 PMO…"},"64de9d25-c1ac-57df-bb34-fa26eff4ff68":{"id":"64de9d25-c1ac-57df-bb34-fa26eff4ff68","path":"/old-README","title":"从实际业务案例，讲解应该如何拆分模块","excerpt":"从实际业务案例，讲解应该如何拆分模块 有太多的文章教你怎么组织代码了。但是这些文章大都是系统A，模块B…"},"dff0ecf5-9f05-58a6-aa77-22c5763c1f6c":{"id":"dff0ecf5-9f05-58a6-aa77-22c5763c1f6c","path":"/今日阅读","title":"今日阅读","excerpt":"7.26 【今日阅读】 https://buttondown.email/nelhage/archive/papers-i-love-gg/  a tool called gg, which is designed to allow users to use cloud…"},"a0c3e1a6-9ef0-56ac-ac0e-ad5e44b177e2":{"id":"a0c3e1a6-9ef0-56ac-ac0e-ad5e44b177e2","path":"/autonomy/README","title":"模块切分的好坏标准是什么？ <a name=\"criteria-of-modularization\"></a>","excerpt":"从 Autonomy…"},"072a9404-179a-5fe9-999e-3b8a34a57b2f":{"id":"072a9404-179a-5fe9-999e-3b8a34a57b2f","path":"/consistency/README","title":"模块切分的好坏标准是什么？ <a name=\"criteria-of-modularization\"></a>","excerpt":"从 Consistency…"},"4bd319a9-7e97-5cf1-8aad-89d3521e37b8":{"id":"4bd319a9-7e97-5cf1-8aad-89d3521e37b8","path":"/docs/Modules","title":"文件、文件夹、Git仓库","excerpt":"拆分是任意的。随意给一个标准，我们都可以把任何东西按照这个标准给拆了。以下是我给的拆分角度： 业务逻辑可以被拆分成： 编辑时：拆分成文件、文件夹、Git仓库 运行时：拆分成进程 这个定义当然不是啥金科玉律。但是它在202…"},"774c883a-11fe-5baa-96f5-4eacca11b812":{"id":"774c883a-11fe-5baa-96f5-4eacca11b812","path":"/docs/README","title":"症状","excerpt":"症状 如果没有做好业务逻辑拆分，可能在项目晚期造成以下三种问题： 拆了微服务之后做一个需求要拉很多人，代码写进来了就再也删不掉了 要么放任自流，1个App里有…"},"75bf3a27-2f68-520d-bf68-dcbd0cda332d":{"id":"75bf3a27-2f68-520d-bf68-dcbd0cda332d","path":"/feedback/README","title":"README","excerpt":"从 Feedback 的角度来看 模块切分的好坏标准是什么？"},"e052788f-529e-5c32-ba0d-22776476ca95":{"id":"e052788f-529e-5c32-ba0d-22776476ca95","path":"/patterns/README","title":"README","excerpt":"…"},"a1fb80ba-8132-58cf-a3ec-a0128f3041e9":{"id":"a1fb80ba-8132-58cf-a3ec-a0128f3041e9","path":"/sample/README","title":"各 Git 仓库","excerpt":"演示 motherboard + 插件 的实现方式 各 Git 仓库 因为是例子，所以下面是用目录模拟的，实际开发中会使用独立 Git 仓库来保存主板和插件的代码 merchandise 面向购物者的商城项目 motherboard 主板 ordinary-product…"},"2bba60e4-bda0-56c5-b644-cfc403144d4e":{"id":"2bba60e4-bda0-56c5-b644-cfc403144d4e","path":"/docs/Part1/AutonomyMetrics","title":"会议时间","excerpt":"我们担心这样的症状： 沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。 需求做了就删不掉：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。 Autonomy…"},"252343fb-64b7-534b-8baa-76b311d48ace":{"id":"252343fb-64b7-534b-8baa-76b311d48ace","path":"/docs/Part1/Composition","title":"相加的关系","excerpt":"相加的关系 显然我们可以把业务逻辑分解成如下的多个Git仓库 这些一次性的Git仓库会相加到一起，就构成了完整的业务逻辑。 相乘的关系 然后我们会意识到，有一些重复的模式。\n比如说这后台的表单都长得差不多啊，我们把表单的校验和错误回显封装个UI…"},"eb84ef0d-2f1b-5ee6-a5a4-7a5d62939523":{"id":"eb84ef0d-2f1b-5ee6-a5a4-7a5d62939523","path":"/docs/Part1/Consensus","title":"真的一点提前设计都不需要吗？","excerpt":"真的一点提前设计都不需要吗？ 是的，需求是不可预测的，不要基于臆想的需求提前设计。 不是的，我们需要在开工之前先取得共识。共识应该包含两部分内容： 我们总是要做出一个“如何分工”的决定，才能开始工作。没有完美的决定，Autonomy/Consistency/Feedback…"},"d5f3879e-9e9b-5fb6-b8b1-6eb824266b6b":{"id":"d5f3879e-9e9b-5fb6-b8b1-6eb824266b6b","path":"/docs/Part1/Consistency","title":"复用不复用那是产品经理的工作","excerpt":"我们担心这样的症状： 难以改全：改一下RPC重试策略，需要把所有调用RPC的地方都改一遍 用户体验不一致：一个APP有4种不同的 date picker 组件，做的都是选日期这个事情 不知道该抄谁：要做一个新界面了，发现类似的界面布局有用 css flexbox…"},"9d512dbb-8c71-5668-bb7c-a5146c1a0711":{"id":"9d512dbb-8c71-5668-bb7c-a5146c1a0711","path":"/docs/Part1/ConsistencyMetrics","title":"必要参数占比","excerpt":"我们可以把 Git 仓库分为 “相加的关系”和“相乘的关系” 。 一致性指标是对“相乘组合关系”的Git…"},"15d16af7-bf6b-5024-9d72-c42764916f52":{"id":"15d16af7-bf6b-5024-9d72-c42764916f52","path":"/docs/Part1/README","title":"Part.1 代码防腐","excerpt":"Part.1 代码防腐 这个 Part 我们主要讨论如何拆分 Git 仓库的问题。我们首先来明确什么样的拆分结果是“好”的，如果拆分不当其症状是什么： 度量 Autonomy 的指标 度量 Consistency…"},"afe47d2a-8e69-567e-89ef-5d40f22b462a":{"id":"afe47d2a-8e69-567e-89ef-5d40f22b462a","path":"/docs/Part2/AutonomyFirst","title":"Autonomy 优先","excerpt":"Autonomy 优先 回到微服务应该怎么拆分，多少个进程是合理的。\n相比  ProcessBoundary ，我认为控制好  FunctionBoundary  和  PluginBoundary  更有利于 Feedback。\n相比  MultiProcess…"},"4d4e90de-af11-560b-84b7-9343207fd621":{"id":"4d4e90de-af11-560b-84b7-9343207fd621","path":"/docs/Part2/ControlBoundary","title":"ControlBoundary","excerpt":"业务逻辑无论如何做拆分，最终仍然是要跑起来，集成到一起去的。\n无论是编辑时拆分成文件、文件夹、Git…"},"0f1c14e4-0070-53bb-8336-9832d19ad5ed":{"id":"0f1c14e4-0070-53bb-8336-9832d19ad5ed","path":"/docs/Part2/ControlChange","title":"ControlChange","excerpt":"…"},"fe182ce5-ec49-5034-9751-22192bca8ae6":{"id":"fe182ce5-ec49-5034-9751-22192bca8ae6","path":"/docs/Part2/FeedbackMetrics","title":"FeedbackMetrics","excerpt":"我们担心这样的症状： 故障定位慢：线上出了bug，要花很长时间才能定位出问题的代码以及对应的开发者。 获得真实反馈慢：代码写完了要等苹果审核发版，错过了这个版本又要等一个月公司才会发下个版本。 本地测试难：稍微有点价值的测试都不是本地可以用 JUnit…"},"0363760e-058d-5b60-99d4-228e7fc00ef1":{"id":"0363760e-058d-5b60-99d4-228e7fc00ef1","path":"/docs/Part2/README","title":"Part.2 只对自己写的代码负责","excerpt":"Part.2 只对自己写的代码负责 这个 Part 我们主要讨论如何拆分进程的事情。标题是“只对自己写的代码负责”，这里包含了两个关键词： 负责：开发者应该对自己的线上服务负责，也就是所谓的 devops…"},"04f5412d-a3ce-5d98-a1f2-766ea1fc83aa":{"id":"04f5412d-a3ce-5d98-a1f2-766ea1fc83aa","path":"/docs/Part3/Prefab","title":"Prefab","excerpt":"复用不复用那是产品经理的工作 Consistency 和 Reuse 的出发点是不同的。\n我对这两个词的感觉是，Reuse 是从所有代码中找重复，然后努力抽取出可复用的东西。\nConsistent 则是我先定义了一个标准，比如说UI…"},"ac72b4b6-5252-505a-a3ef-ba04b9612dc5":{"id":"ac72b4b6-5252-505a-a3ef-ba04b9612dc5","path":"/docs/Part3/README","title":"突出大逻辑，隐藏小细节","excerpt":"突出大逻辑，隐藏小细节 这个 Part 是讲如何“分层”的。Git…"},"5a119092-21b9-5493-9419-f1365a385d05":{"id":"5a119092-21b9-5493-9419-f1365a385d05","path":"/docs/Part3/SignalNoise","title":"SignalNoise","excerpt":"阅读下面这段代码 你的第一印象是什么？我的印象是满屏的sqlMapClient。你能第一眼就说出这段代码中出现了哪些概念，又解决了什么问题吗？或许不是那么容易的事情。如果用DDD的方式来写，也许是这样： 通过阅读上面的代码，我们会发现其中牵涉到了两个领域概念，分别是User…"},"7fd466cc-4461-578e-9773-6ad366e1eff0":{"id":"7fd466cc-4461-578e-9773-6ad366e1eff0","path":"/patterns/event-driven-obstacles/README","title":"问题","excerpt":"问题 事件驱动是大家谈论解耦的时候寄予众望的技术。但是具体到实际的项目中，经常发现事件驱动没有发挥出什么作用。为什么会这样? 分析 基于事件的数据库同步 事件驱动经常变成一种数据库的同步技术。构造一个 Read Model…"},"6999e731-dc60-553e-96f9-f850cd3831bb":{"id":"6999e731-dc60-553e-96f9-f850cd3831bb","path":"/patterns/how-to-add-field/README","title":"问题","excerpt":"问题 经常看见一个表里面有 extra_fields 之类的字段，里面放一个大 JSON…"},"1597b3b0-1cb9-522f-8cdb-3130b759cd4c":{"id":"1597b3b0-1cb9-522f-8cdb-3130b759cd4c","path":"/patterns/how-to-add-new-order-type/README","title":"问题","excerpt":"问题 为了支持新的业务，往往需要给 OrderType 这个字段上添加新的订单类型。为了不影响已有的业务，还经常要加 isNewBiz 这样的“Flag”来标识新的业务场景。除了一直加新的Flag，就没别的办法了吗? 分析 这里有两个问题 添加新的 OrderType…"},"8c5762ff-4c45-51a6-bec3-fe77d1a9e676":{"id":"8c5762ff-4c45-51a6-bec3-fe77d1a9e676","path":"/patterns/how-to-invent-abstraction/README","title":"问题","excerpt":"…"},"e4d25037-e5eb-57e8-a9a3-6f4fd3d6865b":{"id":"e4d25037-e5eb-57e8-a9a3-6f4fd3d6865b","path":"/patterns/how-to-lower-plugin-tax-rate/README","title":"问题","excerpt":"问题 开槽，开插件，都是为了把代码写得更灵活。但是每一开一个扩展点，就需要写一堆样板代码。如何才能降低“插件税”呢? 分析 开一个插件的成本分为两部分 把接口以某种方式定义出来 把模块装配好 UI 组合，以及发 Event…"},"bd30ed1e-e3b4-5059-8e3c-90a48bdb7aea":{"id":"bd30ed1e-e3b4-5059-8e3c-90a48bdb7aea","path":"/patterns/how-to-maintain-readability/README","title":"问题","excerpt":"问题 为了代码复用，拆了很多个模块，导致代码不好阅读了怎么办? 之前代码虽然写的挫，但是 ctrl+f…"},"024aa835-b87a-5b9c-89d5-8d08f5e8eae4":{"id":"024aa835-b87a-5b9c-89d5-8d08f5e8eae4","path":"/patterns/ui-composition-obstacles/README","title":"问题","excerpt":"问题 松耦合模块边界的最佳范例就是基于 UI 的组合。但是为什么在过去的历史经验里，这样的模块切分的方式很难落地? 有没有什么具体的技术方案可以借鉴? 分析 这个原因是非常多方面的 按职能分工 一个人的时间和精力都是有限的。因为 UI…"},"723f34b8-15db-5761-bdae-266f84069f29":{"id":"723f34b8-15db-5761-bdae-266f84069f29","path":"/sample/stableinf/README","title":"stableinf","excerpt":"stableinf 是 stable interface 的缩写，是为了支持“基于稳定接口分工”的基础设施。最常见的稳定接口的例子就是“基于 UI 的集成”。然而目前基础设施的限制严重阻碍了“基于 UI…"},"a55d7f92-fcf4-59e3-83f9-6e446e501769":{"id":"a55d7f92-fcf4-59e3-83f9-6e446e501769","path":"/autonomy/criteria-of-modularization/avoid-crazy-busy-top-module/README","title":"README","excerpt":"假设在一个虚构的电商业务里，我们有如下的模块划分结构 底下的各个微服务之间互相没有依赖关系。为了实现业务流程，安排了一个“业务编排API”模块来把这些微服务串联起来。同时为了让前端开发迭代效率更高，前端团队用serverless搭建了一个BFF模块（Backend for…"},"bb85ffcd-25b5-5900-a699-2faf0d00b6c1":{"id":"bb85ffcd-25b5-5900-a699-2faf0d00b6c1","path":"/autonomy/criteria-of-modularization/common-module-should-be-stable/README","title":"README","excerpt":"…"},"05cc69cf-4fdf-5f65-836a-8384f7c7d496":{"id":"05cc69cf-4fdf-5f65-836a-8384f7c7d496","path":"/autonomy/criteria-of-modularization/extending-by-adding-new-module/README","title":"README","excerpt":"在 vscode 中，我们有如下的模块划分结构 其中 vscode 提供了字符输入，换行，响应鼠标等基础的编辑器。typescript-basics 模块依赖了 vscode，提供了代码区块的折叠能力（识别typescript的class/function…"},"3acaebe6-9890-55dd-8c17-68e28e19ae40":{"id":"3acaebe6-9890-55dd-8c17-68e28e19ae40","path":"/autonomy/criteria-of-modularization/more-focus-on-violatility-than-functionality/README","title":"README","excerpt":"…"},"a17e9eb9-bc80-5ea0-8e54-91dea6628f94":{"id":"a17e9eb9-bc80-5ea0-8e54-91dea6628f94","path":"/autonomy/loosely-coupled-interface/no-return-value/README","title":"README","excerpt":"…"},"f4426aac-515c-56e8-9468-d08987e1ff25":{"id":"f4426aac-515c-56e8-9468-d08987e1ff25","path":"/autonomy/loosely-coupled-interface/ui-composition/README","title":"README","excerpt":"下面这个例子来自于 Finding your service boundaries - a practical guide - Adam Ralph ( https://www.youtube.com/watch?v=tVnIUZbsxWI&t=2482s…"},"003362b8-fe08-5622-bed1-5aafe840069f":{"id":"003362b8-fe08-5622-bed1-5aafe840069f","path":"/autonomy/loosely-coupled-interface/virtual-file-system/README","title":"README","excerpt":"假设有这么一个虚构的故障检测与分析的业务， 其模块构成如下 从网络探针，主机Agent等多个渠道，都会有探测器不断上报到消息队列里。掉底watchdog…"},"86cb0db6-ea6a-5c46-9246-e881f6d25c5c":{"id":"86cb0db6-ea6a-5c46-9246-e881f6d25c5c","path":"/autonomy/module-boundary-unchanged/alibaba-middle-office-technology/README","title":"参考资料","excerpt":"参考资料 下面是关于阿里中台的一些公开资料 TMF & 星环 阿里玄难：面向不确定性的软件设计几点思考  https://mp.weixin.qq.com/s/Uc_wJSVQr7sSz2js2pb3OA 如何实现32.5万笔/秒的交易峰值？阿里交易系统TMF2.…"},"497107bb-fbbd-5473-9ce1-92f7561483d1":{"id":"497107bb-fbbd-5473-9ce1-92f7561483d1","path":"/autonomy/module-boundary-unchanged/packaging-deployment/README","title":"单个 React 组件","excerpt":"以下是从 链家的网站 上截的几个图。这个工具是给中介帮二手房买卖双方计算税费使用的。 \n \n \n 其核心逻辑是收集房子，卖家，买家三个业务实体的属性。然后根据当地的法规制度，计算出各种税费的税率，然后算出总共应该交的税费的总表。 单个 React…"},"8b682fbc-ed2c-5368-a51e-0b46ce81f9d7":{"id":"8b682fbc-ed2c-5368-a51e-0b46ce81f9d7","path":"/autonomy/module-boundary-unchanged/replace-class-with-interface/README","title":"README","excerpt":"在一个虚构的电商系统中，我们有如下的模块划分 其中购物车实现了价格的计算，包括整个 invoice 的 total，以及每个 line item…"},"3b9f90f3-2f7a-54f1-bc6b-17f1338e6b95":{"id":"3b9f90f3-2f7a-54f1-bc6b-17f1338e6b95","path":"/consistency/criteria-of-modularization/non-functional-should-be-consistent/README","title":"README","excerpt":"假设你有一个微服务架构，其中包含了前台业务模块，以及订单模块，策略模块，商家店铺模块。分别采用了 HTTP REST 接口，GRpc 接口，Thrift 接口。所有的 RPC 库都是用编程语言自带的网络库来完成的。其中 HTTP REST 接口更过分，是每一个不同的 URL…"},"be460b6a-a260-5b71-a0d6-0f4d28573194":{"id":"be460b6a-a260-5b71-a0d6-0f4d28573194","path":"/docs/Part1/AmazonExample/README","title":"README","excerpt":"下面这个例子来自于 Finding your service boundaries - a practical guide - Adam Ralph ( https://www.youtube.com/watch?v=tVnIUZbsxWI&t=2482s…"},"ae5931da-0cb7-5a13-82e2-f852f6c3b596":{"id":"ae5931da-0cb7-5a13-82e2-f852f6c3b596","path":"/docs/Part1/InformationHiding/README","title":"信息隐藏","excerpt":"信息隐藏 通过信息隐藏，我们把代码分为“可以随便写的”和“不可以随便写的”两部分。从而控制代码腐化的蔓延。 Class 的信息隐藏 我们都知道 Class 有一个叫封装的概念。把 Field 和 Method 分为 Public / Private / Protected…"},"b8f62f0d-1008-5db1-aef3-11749a8b0c25":{"id":"b8f62f0d-1008-5db1-aef3-11749a8b0c25","path":"/docs/Part1/Integration/README","title":"常见的需求模式","excerpt":"常见的需求模式 抽象的A、B、C这样的描述是没有代入感的。遇到实际的业务逻辑，仍然不知道怎么拆解。 在实际的业务实现过程中，经常发现 Autonomy…"},"20efd819-0fbf-51d5-8628-8175b1e9198b":{"id":"20efd819-0fbf-51d5-8628-8175b1e9198b","path":"/docs/Part1/Scenario/README","title":"README","excerpt":"这里根据有限的经验，列举几个常见的场景。 用户可见的一致性 优化 Autonomy 优化 Feedback"},"07370c98-648f-58ea-9c43-5a8e1747e007":{"id":"07370c98-648f-58ea-9c43-5a8e1747e007","path":"/docs/Part1/VscodeExample/README","title":"README","excerpt":"在 vscode 中，我们有如下的模块划分结构 其中 vscode 提供了字符输入，换行，响应鼠标等基础的编辑器。typescript-basics 模块依赖了 vscode，提供了代码区块的折叠能力（识别typescript的class/function…"},"42fcf9c8-7def-5d13-8bd3-6c026d7af35c":{"id":"42fcf9c8-7def-5d13-8bd3-6c026d7af35c","path":"/docs/Part2/FunctionBoundary/README","title":"同步调用栈","excerpt":"除了进程之外，函数是一个所有编程语言，所有运行时平台都有的概念。\n每次函数调用都有一个运行时的 StackFrame 的数据结构来代表这次调用，某种程度上这就造成了函数的边界。 假设我们要在函数这个层面获得Feedback…"},"6f4b2bc3-471a-5e97-b0a2-56a6c2278620":{"id":"6f4b2bc3-471a-5e97-b0a2-56a6c2278620","path":"/docs/Part2/MultiProcess/README","title":"README","excerpt":"因为大部分线上故障都是由变更引起的，所以SRE…"},"1d770397-47a4-5d04-8fd2-7c6dbca70683":{"id":"1d770397-47a4-5d04-8fd2-7c6dbca70683","path":"/docs/Part2/MultiTenancy/README","title":"README","excerpt":"…"},"e8b8f28f-326f-51b8-9a34-dedbc708625d":{"id":"e8b8f28f-326f-51b8-9a34-dedbc708625d","path":"/docs/Part2/MultiVariant/README","title":"README","excerpt":"考虑以下三种做法： 在代码中埋入 Feature Flag，通过配置中心下发开或者关，或者对一部分流量打开 在本地的笔记本上启动一个独立的精简集群做测试开发 在本地的笔记本上只启动一个进程，集群的其余的进程使用生产环境的 我把这三种做法都归纳为 Multi Variant…"},"a7776948-d7c4-5e92-8891-d9ca70d3074f":{"id":"a7776948-d7c4-5e92-8891-d9ca70d3074f","path":"/docs/Part2/PluginBoundary/README","title":"README","excerpt":"通过多进程，我们可以实现业务逻辑的动态组合。但是用普通函数也可以组合 这样 f 和 g 就组合起来了，我们称 g 为一个插件。\n插件边界是指当 f 和 g 来自于不同的 git 仓库的时候，f 调用 g 就是跨越了 git 仓库的边界。\n那怎么能实现 f 和 g…"},"8fc6722d-22e1-59a6-bb62-cfa514426984":{"id":"8fc6722d-22e1-59a6-bb62-cfa514426984","path":"/docs/Part2/ProcessBoundary/README","title":"README","excerpt":"把不同的 Git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道是由哪个 Git…"},"62501440-0c07-5295-86a8-d02ec26c10f9":{"id":"62501440-0c07-5295-86a8-d02ec26c10f9","path":"/sample/stableinf/cloud/README","title":"README","excerpt":"云服务部署的抽象接口，屏蔽云厂商的差异"},"ddc3562a-da5d-51d1-97b3-f1cfd9eb4745":{"id":"ddc3562a-da5d-51d1-97b3-f1cfd9eb4745","path":"/sample/stableinf/demo/README","title":"README","excerpt":"演示如何使用输入与输出"},"936187f2-3a30-5000-91f6-0b99dc078a69":{"id":"936187f2-3a30-5000-91f6-0b99dc078a69","path":"/sample/stableinf/cloud-mem/README","title":"README","excerpt":"基于内存实现的假 Cloud"},"5b9f8204-8f1e-55f7-a23a-c3dc81b17568":{"id":"5b9f8204-8f1e-55f7-a23a-c3dc81b17568","path":"/sample/stableinf/deploy/README","title":"持续部署","excerpt":"持续部署 源代码 => cloud，本地开发与生产环境部署脚本同构 监听文件系统，发现源代码改动 插件和主板合并 静态代码生成 模型定义导出 typescript => javascript 推荐数据迁移SQL javascript 合并成大bundle 基于 cloud…"},"d8597f2d-e0a2-5724-87fa-52132e9561a5":{"id":"d8597f2d-e0a2-5724-87fa-52132e9561a5","path":"/sample/stableinf/io/README","title":"提供三种 I/O 外设的标准接口","excerpt":"提供三种 I/O 外设的标准接口 RPC 调用：ServiceProtocol.callService 关系型数据库单表：Database.insert/Database.query/ActiveRecord.update/ActiveRecord.delete…"},"6ede4393-8ba5-5bef-9906-6c542e412279":{"id":"6ede4393-8ba5-5bef-9906-6c542e412279","path":"/sample/stableinf/rx-react/README","title":"目的","excerpt":"目的 react 并不 reactive。 rx-react 其目的是为了让 react 组件能够订阅它读取了的 ActiveRecord，包括浏览器本地内存数据库里的 ActiveRecord（所谓前端 store），以及远程服务后面的 Active（可能是存在 MySQL…"},"11719b7d-670d-5044-b099-e660917a30ab":{"id":"11719b7d-670d-5044-b099-e660917a30ab","path":"/docs/Part1/DependencyInversion/README","title":"装配逻辑","excerpt":"装配逻辑 最理想的拆分后又组合的方式是“粘贴”到一起。就像你把一块砖，劈开了。拼装回去就是把两半又放一起。也就是我们可以有一个通用的函数 integrate(comp1, comp2, .. compN…"},"3da3745d-8a2e-5868-9577-7c63272da3d8":{"id":"3da3745d-8a2e-5868-9577-7c63272da3d8","path":"/docs/Part1/Integration/DiscreteProcess/README","title":"离散型流程","excerpt":"离散型流程 例如在订单成交之后，给中介分佣这一类的业务。它们有三个特点 不需要返回值。也就是只需要在时间顺序上，安排在之后发生。 不精确要求立即执行。稍微晚个几秒是可以忍受的。 不影响事务结果。不因为分佣服务挂了，导致订单无法成交。 事件驱动 订单的 Git…"},"6dbcdd8c-9287-5d30-abcb-65c3d6c3a5c6":{"id":"6dbcdd8c-9287-5d30-abcb-65c3d6c3a5c6","path":"/docs/Part1/Integration/DiscreteUI/README","title":"离散型 UI","excerpt":"离散型 UI 这一类的需求是展示一个界面。界面上可以非常很多个块。每一块的业务逻辑都可以分离到一个独立的Git…"},"de5727d7-82c2-5879-a2dc-1445c1eb03fa":{"id":"de5727d7-82c2-5879-a2dc-1445c1eb03fa","path":"/docs/Part1/Integration/Library/README","title":"领先技术","excerpt":"领先技术 需求可能包含了对领先技术的需要。比如如果旗下有很多款长视频，短视频，直播类的 App，这家公司对领先的视频压缩算法的需求就会非常强烈。这些领先技术会有如下特点 可能成为“Library”被多次复用：其 Git…"},"3a49e65d-73b6-5458-9a0c-501f7624ad41":{"id":"3a49e65d-73b6-5458-9a0c-501f7624ad41","path":"/docs/Part1/Integration/MixedProcess/README","title":"混合型流程","excerpt":"…"},"68d910b7-564d-54de-bde5-03213692008d":{"id":"68d910b7-564d-54de-bde5-03213692008d","path":"/docs/Part1/Integration/MixedUI/README","title":"混合型 UI","excerpt":"混合型 UI 这一类需求和离散型 UI 不同。界面上没有明显的大区块。很难说哪个 Git 仓库可以把完整的一部分拿走。例如 购物车是典型的混合型 UI。没有哪个 Git…"},"bac4e097-cb7c-5101-a30c-aba79a5536a5":{"id":"bac4e097-cb7c-5101-a30c-aba79a5536a5","path":"/docs/Part1/Integration/ProductFamily/README","title":"产品族","excerpt":"产品族 由用户挑选自己所需要的产品，动态装配出符合用户需要的软件功能。用户的需求表单可能是单参数的，例如通过不同按钮下的订单，orderType 就不同。\n用户的需求也可能是分阶段，多参数的，例如用户可能先选了专车，然后又表达了自己需要儿童座椅。有很多种装配多个 Git…"},"bde50e4a-d8a1-5eb5-b2f1-563bd1b97f7c":{"id":"bde50e4a-d8a1-5eb5-b2f1-563bd1b97f7c","path":"/docs/Part1/Scenario/AutonomyOptimization/README","title":"优化 Autonomy","excerpt":"优化 Autonomy 为了达成 “各写各的” 的目的，在一口锅里吃饭总是要先有一些规矩的。 这部分的一致性主要靠上层业务的 stakeholder 去推动，因为独立自主是他们受益，他们是最有动力保持互相没有关系的状态。\n如果各个 stakeholder…"},"57e35068-3bb8-5a1e-bc78-0f3d55fa9e6a":{"id":"57e35068-3bb8-5a1e-bc78-0f3d55fa9e6a","path":"/docs/Part1/Scenario/FeedbackOptimization/README","title":"优化 Feedback","excerpt":"优化 Feedback 在 Feedback 这部分，我们讨论了“控制边界”和“控制变更”这两部分内容。这分别对应了监控和发布变更这两项运维的传统职能。\n在监控系统，发布部署系统的选择方面，要保持一致性并不难，运维强推就可以。 如果要更精细一些的Feedback…"},"e6ea2d16-7f16-52c8-8316-1f8b00bc0f41":{"id":"e6ea2d16-7f16-52c8-8316-1f8b00bc0f41","path":"/docs/Part1/Scenario/UserInterface/README","title":"用户可见的一致性","excerpt":"用户可见的一致性 用户可见的一致性包括以下三类： 颜色、字体 布局组件 以表单为代表的预制件 颜色、字体应该是全局设置，而不是在每个地方用 css 指定颜色的 RGB 值。就算要覆盖全局的设置，也应该是用 prominent 之类的变量名字来引用颜色，而不是用 RGB…"},"637ac43d-29dd-577d-ac3e-f6b74bb96080":{"id":"637ac43d-29dd-577d-ac3e-f6b74bb96080","path":"/public/75ea132c7557befb0f8bfe1f1b83b12d/modularization","title":"模块化的三个目的","excerpt":"Autonomy 所有人似乎都在修改同一个文件，例如 order.php。所有需求似乎都堆积在少数几个人的身上。所有团队似乎都等着同一个模块的上线，但是一天只有24小时，没有足够的时间去在生产环境验证新部署的可靠性。公司里的 PMO…"},"8a33b056-f452-5e4b-9871-cdcb819eb42e":{"id":"8a33b056-f452-5e4b-9871-cdcb819eb42e","path":"/public/0f01ea8a82a6b37616d40df0defe6aea/Prefab","title":"Prefab","excerpt":"复用不复用那是产品经理的工作 Consistency 和 Reuse 的出发点是不同的。\n我对这两个词的感觉是，Reuse 是从所有代码中找重复，然后努力抽取出可复用的东西。\nConsistent 则是我先定义了一个标准，比如说UI…"},"4e2c5436-c76e-5f2b-9acb-a1e282e3318c":{"id":"4e2c5436-c76e-5f2b-9acb-a1e282e3318c","path":"/public/1002f2dd59c34027813c1ff79b8a5dc0/README","title":"README","excerpt":"因为大部分线上故障都是由变更引起的，所以SRE…"},"48a286a4-8c55-5fcd-ba28-523fb3adc9ef":{"id":"48a286a4-8c55-5fcd-ba28-523fb3adc9ef","path":"/public/1d54e33d20612ee97a16d32ff6f1d1e9/ControlChange","title":"ControlChange","excerpt":"…"},"644d1c1a-9065-524e-b71b-264e9510a6fc":{"id":"644d1c1a-9065-524e-b71b-264e9510a6fc","path":"/public/2845810cd7fc116f66c826b5f23613e3/AutonomyMetrics","title":"会议时间","excerpt":"我们担心这样的症状： 沟通多：做新需求很难，因为需要牵涉到很多的团队，要和大量的人去沟通才能把需求落地。 需求做了就删不掉：一旦需求做进去了之后，即便愿意把这个功能下线也非常困难。遗留代码日积月累。 Autonomy…"},"056c3887-2081-5cca-8526-f997cd400a61":{"id":"056c3887-2081-5cca-8526-f997cd400a61","path":"/public/291b8fc9439b4eff072c721acd627efc/README","title":"优化 Autonomy","excerpt":"优化 Autonomy 为了达成 “各写各的” 的目的，在一口锅里吃饭总是要先有一些规矩的。 这部分的一致性主要靠上层业务的 stakeholder 去推动，因为独立自主是他们受益，他们是最有动力保持互相没有关系的状态。\n如果各个 stakeholder…"},"ce1c5c4f-a202-5f4d-97d7-a220737cd1d0":{"id":"ce1c5c4f-a202-5f4d-97d7-a220737cd1d0","path":"/public/2fc42e300eac629d58b88ca57a27f53d/README","title":"README","excerpt":"…"},"fe8a4f0c-cd86-5c8a-bfdf-37247bd503c5":{"id":"fe8a4f0c-cd86-5c8a-bfdf-37247bd503c5","path":"/public/44fa9eaf00084f5ae7486801d86243e7/Consensus","title":"真的一点提前设计都不需要吗？","excerpt":"真的一点提前设计都不需要吗？ 是的，需求是不可预测的，不要基于臆想的需求提前设计。 不是的，我们需要在开工之前先取得共识。共识应该包含两部分内容： 我们总是要做出一个“如何分工”的决定，才能开始工作。没有完美的决定，Autonomy/Consistency/Feedback…"},"70320899-7ac6-5a35-8c28-da132c03ab9a":{"id":"70320899-7ac6-5a35-8c28-da132c03ab9a","path":"/public/457b6c05929853aac75cdfd463ac5be1/README","title":"README","excerpt":"把不同的 Git 仓库跑在不同的进程里。这样只要看是哪个进程出的问题，就可以知道是由哪个 Git…"},"5979bd55-279e-5fb1-80f1-b04f53d82461":{"id":"5979bd55-279e-5fb1-80f1-b04f53d82461","path":"/public/45a837973d87ef32c996658a96093ab4/README","title":"混合型 UI","excerpt":"混合型 UI 这一类需求和离散型 UI 不同。界面上没有明显的大区块。很难说哪个 Git 仓库可以把完整的一部分拿走。例如 购物车是典型的混合型 UI。没有哪个 Git…"},"ac14dc34-6bbc-5f53-abcf-75f25d3414c9":{"id":"ac14dc34-6bbc-5f53-abcf-75f25d3414c9","path":"/public/4a7361a84b55ce968e57cf1f36b21301/README","title":"离散型 UI","excerpt":"离散型 UI 这一类的需求是展示一个界面。界面上可以非常很多个块。每一块的业务逻辑都可以分离到一个独立的Git…"},"0e7ec9bd-4248-5c50-829d-ca2bf5013261":{"id":"0e7ec9bd-4248-5c50-829d-ca2bf5013261","path":"/public/4b6389c3a33c15dd3606f91d9cdfb647/ConsistencyMetrics","title":"必要参数占比","excerpt":"我们可以把 Git 仓库分为 “相加的关系”和“相乘的关系” 。 一致性指标是对“相乘组合关系”的Git…"},"b7722e1c-b2ef-5204-9c8e-36c6fcbd3116":{"id":"b7722e1c-b2ef-5204-9c8e-36c6fcbd3116","path":"/public/5235411dec9bacf74609e7054c349064/README","title":"Part.2 只对自己写的代码负责","excerpt":"Part.2 只对自己写的代码负责 这个 Part 我们主要讨论如何拆分进程的事情。标题是“只对自己写的代码负责”，这里包含了两个关键词： 负责：开发者应该对自己的线上服务负责，也就是所谓的 devops…"},"95967f6a-2e2d-54e6-b106-026aeafd69e7":{"id":"95967f6a-2e2d-54e6-b106-026aeafd69e7","path":"/public/544d9708da25a6372feeb016f30d00ca/README","title":"README","excerpt":"考虑以下三种做法： 在代码中埋入 Feature Flag，通过配置中心下发开或者关，或者对一部分流量打开 在本地的笔记本上启动一个独立的精简集群做测试开发 在本地的笔记本上只启动一个进程，集群的其余的进程使用生产环境的 我把这三种做法都归纳为 Multi Variant…"},"543a3e12-3142-5127-a2d6-3c6f3bf774f2":{"id":"543a3e12-3142-5127-a2d6-3c6f3bf774f2","path":"/public/63369a78a814fb1585e88e2c7a8a4bb9/README","title":"README","excerpt":"…"},"b0272621-0e85-555d-8fce-4fbd71ff213b":{"id":"b0272621-0e85-555d-8fce-4fbd71ff213b","path":"/public/635c2cabc78b648f10fa5dea7571b0fe/README","title":"README","excerpt":"这里根据有限的经验，列举几个常见的场景。 用户可见的一致性 优化 Autonomy 优化 Feedback"},"e7dacbf6-8d60-5d5b-b22c-93e24d2e11e1":{"id":"e7dacbf6-8d60-5d5b-b22c-93e24d2e11e1","path":"/public/73e62a0e0cd5fb928bec95e0d035d5c0/README","title":"README","excerpt":"通过多进程，我们可以实现业务逻辑的动态组合。但是用普通函数也可以组合 这样 f 和 g 就组合起来了，我们称 g 为一个插件。\n插件边界是指当 f 和 g 来自于不同的 git 仓库的时候，f 调用 g 就是跨越了 git 仓库的边界。\n那怎么能实现 f 和 g…"},"3f7615b8-73ff-50e9-9290-12296a78ae64":{"id":"3f7615b8-73ff-50e9-9290-12296a78ae64","path":"/public/75879cf5253ff17a77c994b019a4c306/README","title":"信息隐藏","excerpt":"信息隐藏 通过信息隐藏，我们把代码分为“可以随便写的”和“不可以随便写的”两部分。从而控制代码腐化的蔓延。 Class 的信息隐藏 我们都知道 Class 有一个叫封装的概念。把 Field 和 Method 分为 Public / Private / Protected…"},"e0b6fe78-8d7f-5a93-ade1-6841a160eb13":{"id":"e0b6fe78-8d7f-5a93-ade1-6841a160eb13","path":"/public/8af17b1bc2ea157bd39f8674a598d84d/README","title":"突出大逻辑，隐藏小细节","excerpt":"突出大逻辑，隐藏小细节 这个 Part 是讲如何“分层”的。Git…"},"6da60e99-307b-58b8-b355-4cc72e5513b9":{"id":"6da60e99-307b-58b8-b355-4cc72e5513b9","path":"/public/99d03f7b09ff45575a3dfced970a4387/README","title":"模块切分的好坏标准是什么？ <a name=\"criteria-of-modularization\"></a>","excerpt":"从 Autonomy…"},"edf2ed96-d52f-57da-be5a-fd55efe8c16a":{"id":"edf2ed96-d52f-57da-be5a-fd55efe8c16a","path":"/public/a1470faaac3073438c436b606487c4c1/Modules","title":"文件、文件夹、Git仓库","excerpt":"拆分是任意的。随意给一个标准，我们都可以把任何东西按照这个标准给拆了。以下是我给的拆分角度： 业务逻辑可以被拆分成： 编辑时：拆分成文件、文件夹、Git仓库 运行时：拆分成进程 这个定义当然不是啥金科玉律。但是它在202…"},"aabd09b0-d524-5cbb-b55c-48d7acb93d5e":{"id":"aabd09b0-d524-5cbb-b55c-48d7acb93d5e","path":"/public/a711eae1b3abb9ad555d4a65e13f486d/SignalNoise","title":"SignalNoise","excerpt":"阅读下面这段代码 你的第一印象是什么？我的印象是满屏的sqlMapClient。你能第一眼就说出这段代码中出现了哪些概念，又解决了什么问题吗？或许不是那么容易的事情。如果用DDD的方式来写，也许是这样： 通过阅读上面的代码，我们会发现其中牵涉到了两个领域概念，分别是User…"},"cfe9079d-0cb3-5cfe-8ed4-527b92d7447a":{"id":"cfe9079d-0cb3-5cfe-8ed4-527b92d7447a","path":"/public/adb325fb1b15c2a2a7b135e80b5808e4/README","title":"混合型流程","excerpt":"…"},"0980b01d-ba8f-57ba-b55c-3d7913341948":{"id":"0980b01d-ba8f-57ba-b55c-3d7913341948","path":"/public/b07b0f1499745d6b74ab5780fabef82e/README","title":"同步调用栈","excerpt":"除了进程之外，函数是一个所有编程语言，所有运行时平台都有的概念。\n每次函数调用都有一个运行时的 StackFrame 的数据结构来代表这次调用，某种程度上这就造成了函数的边界。 假设我们要在函数这个层面获得Feedback…"},"67c12ea3-9794-54c5-968f-d20c8639fb29":{"id":"67c12ea3-9794-54c5-968f-d20c8639fb29","path":"/public/b31870cd7fa42c952b4cbff586313b04/README","title":"产品族","excerpt":"产品族 由用户挑选自己所需要的产品，动态装配出符合用户需要的软件功能。用户的需求表单可能是单参数的，例如通过不同按钮下的订单，orderType 就不同。\n用户的需求也可能是分阶段，多参数的，例如用户可能先选了专车，然后又表达了自己需要儿童座椅。有很多种装配多个 Git…"},"6be6a95b-5963-5d36-9eca-e3d81d67581b":{"id":"6be6a95b-5963-5d36-9eca-e3d81d67581b","path":"/public/b7313b19f868d6d37dc46059b496b55f/README","title":"离散型流程","excerpt":"离散型流程 例如在订单成交之后，给中介分佣这一类的业务。它们有三个特点 不需要返回值。也就是只需要在时间顺序上，安排在之后发生。 不精确要求立即执行。稍微晚个几秒是可以忍受的。 不影响事务结果。不因为分佣服务挂了，导致订单无法成交。 事件驱动 订单的 Git…"},"9eb847d5-74b6-5679-9fa1-17971fa24b43":{"id":"9eb847d5-74b6-5679-9fa1-17971fa24b43","path":"/public/c164b855124f53aae36f387a9d45dd17/README","title":"领先技术","excerpt":"领先技术 需求可能包含了对领先技术的需要。比如如果旗下有很多款长视频，短视频，直播类的 App，这家公司对领先的视频压缩算法的需求就会非常强烈。这些领先技术会有如下特点 可能成为“Library”被多次复用：其 Git…"},"b1f247f6-fb44-5b0b-86b5-ffd2c51fb5e0":{"id":"b1f247f6-fb44-5b0b-86b5-ffd2c51fb5e0","path":"/public/d314499db7740fa159d296655a8a1699/README","title":"用户可见的一致性","excerpt":"用户可见的一致性 用户可见的一致性包括以下三类： 颜色、字体 布局组件 以表单为代表的预制件 颜色、字体应该是全局设置，而不是在每个地方用 css 指定颜色的 RGB 值。就算要覆盖全局的设置，也应该是用 prominent 之类的变量名字来引用颜色，而不是用 RGB…"},"deb42fd3-3dfb-5620-988f-4ba6e3d48656":{"id":"deb42fd3-3dfb-5620-988f-4ba6e3d48656","path":"/public/e18d0e5a07ec679267c193de1df2e1c4/README","title":"优化 Feedback","excerpt":"优化 Feedback 在 Feedback 这部分，我们讨论了“控制边界”和“控制变更”这两部分内容。这分别对应了监控和发布变更这两项运维的传统职能。\n在监控系统，发布部署系统的选择方面，要保持一致性并不难，运维强推就可以。 如果要更精细一些的Feedback…"},"2d1f3248-f548-5c2a-ba85-22e8f7d24b15":{"id":"2d1f3248-f548-5c2a-ba85-22e8f7d24b15","path":"/public/f7baef482c469f580a7cb1ccafa6f98a/FeedbackMetrics","title":"FeedbackMetrics","excerpt":"我们担心这样的症状： 故障定位慢：线上出了bug，要花很长时间才能定位出问题的代码以及对应的开发者。 获得真实反馈慢：代码写完了要等苹果审核发版，错过了这个版本又要等一个月公司才会发下个版本。 本地测试难：稍微有点价值的测试都不是本地可以用 JUnit…"},"8dd36698-ba14-598b-a214-cce2ef6cd8f8":{"id":"8dd36698-ba14-598b-a214-cce2ef6cd8f8","path":"/public/f7e037331dc8a79b8bdb96914ed52545/Composition","title":"相加的关系","excerpt":"相加的关系 显然我们可以把业务逻辑分解成如下的多个Git仓库 这些一次性的Git仓库会相加到一起，就构成了完整的业务逻辑。 相乘的关系 然后我们会意识到，有一些重复的模式。\n比如说这后台的表单都长得差不多啊，我们把表单的校验和错误回显封装个UI…"},"0805bab3-ffb9-5810-8229-ecebb80457b9":{"id":"0805bab3-ffb9-5810-8229-ecebb80457b9","path":"/public/fbac9065024e47637755858fba58bfc1/README","title":"Part.1 代码防腐","excerpt":"Part.1 代码防腐 这个 Part 我们主要讨论如何拆分 Git 仓库的问题。我们首先来明确什么样的拆分结果是“好”的，如果拆分不当其症状是什么： 度量 Autonomy 的指标 度量 Consistency…"},"b968bfb9-449d-5bc4-ae84-744b7604a1f9":{"id":"b968bfb9-449d-5bc4-ae84-744b7604a1f9","path":"/public/fdfccf3b93de05f5013be8e8ee46e839/ControlBoundary","title":"ControlBoundary","excerpt":"业务逻辑无论如何做拆分，最终仍然是要跑起来，集成到一起去的。\n无论是编辑时拆分成文件、文件夹、Git…"},"14dddf20-4f46-5101-8de2-cd62e8f8fbf1":{"id":"14dddf20-4f46-5101-8de2-cd62e8f8fbf1","path":"/public/142388d4e5a02585151e424aef5c7488/README","title":"装配逻辑","excerpt":"装配逻辑 最理想的拆分后又组合的方式是“粘贴”到一起。就像你把一块砖，劈开了。拼装回去就是把两半又放一起。也就是我们可以有一个通用的函数 integrate(comp1, comp2, .. compN…"},"e65f99c2-a720-55e7-b0d0-10f4c0b9644b":{"id":"e65f99c2-a720-55e7-b0d0-10f4c0b9644b","path":"/public/38d8bb4d89104dd45250205e0e545dee/README","title":"常见的需求模式","excerpt":"常见的需求模式 抽象的A、B、C这样的描述是没有代入感的。遇到实际的业务逻辑，仍然不知道怎么拆解。 在实际的业务实现过程中，经常发现 Autonomy…"},"b01d484f-f6ce-5603-bde6-471a2a3c17a8":{"id":"b01d484f-f6ce-5603-bde6-471a2a3c17a8","path":"/public/3bf09cdb2892d5274211d8f4f8a660db/README","title":"README","excerpt":"在 vscode 中，我们有如下的模块划分结构 其中 vscode 提供了字符输入，换行，响应鼠标等基础的编辑器。typescript-basics 模块依赖了 vscode，提供了代码区块的折叠能力（识别typescript的class/function…"},"7ceaca93-78bf-536a-bef1-7aee471d15b4":{"id":"7ceaca93-78bf-536a-bef1-7aee471d15b4","path":"/public/f0affe5b61d9b2f5cbf4ef11ef5e1bfe/README","title":"README","excerpt":"下面这个例子来自于 Finding your service boundaries - a practical guide - Adam Ralph ( https://www.youtube.com/watch?v=tVnIUZbsxWI&t=2482s…"}}